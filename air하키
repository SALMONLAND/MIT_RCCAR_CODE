import tkinter as tk
from tkinter import ttk, scrolledtext
import serial
import serial.tools.list_ports
import threading
import time
import re

class ArduinoMonitor:
    def __init__(self, root):
        self.root = root
        self.root.title("ğŸ¯ ì•„ë‘ì´ë…¸ ë¬¼ì²´ ê°ì§€ ëª¨ë‹ˆí„°")
        self.root.geometry("900x700")
        self.root.configure(bg='#1a1a2e')
        
        self.serial_port = None
        self.is_running = False
        self.score = 0
        self.distance = 0
        self.status = "ëŒ€ê¸° ì¤‘"
        
        self.setup_ui()
        
    def setup_ui(self):
        # ìƒë‹¨ í”„ë ˆì„ - ì—°ê²° ì„¤ì •
        top_frame = tk.Frame(self.root, bg='#16213e', padx=15, pady=15)
        top_frame.pack(fill='x')
        
        tk.Label(top_frame, text="í¬íŠ¸ ì„ íƒ:", bg='#16213e', fg='white', 
                font=('ë§‘ì€ ê³ ë”•', 11, 'bold')).pack(side='left', padx=5)
        
        self.port_combo = ttk.Combobox(top_frame, width=20, state='readonly', 
                                       font=('ë§‘ì€ ê³ ë”•', 10))
        self.port_combo.pack(side='left', padx=5)
        self.refresh_ports()
        
        self.connect_btn = tk.Button(top_frame, text="ğŸ”Œ ì—°ê²°", command=self.toggle_connection,
                                     bg='#0f3460', fg='white', font=('ë§‘ì€ ê³ ë”•', 11, 'bold'),
                                     padx=25, pady=8, relief='flat', cursor='hand2')
        self.connect_btn.pack(side='left', padx=10)
        
        self.refresh_btn = tk.Button(top_frame, text="ğŸ”„ ìƒˆë¡œê³ ì¹¨", command=self.refresh_ports,
                                     bg='#533483', fg='white', font=('ë§‘ì€ ê³ ë”•', 10),
                                     padx=15, pady=8, relief='flat', cursor='hand2')
        self.refresh_btn.pack(side='left', padx=5)
        
        self.status_label = tk.Label(top_frame, text="â— ì—°ê²° ì•ˆë¨", bg='#16213e', 
                                     fg='#ff4757', font=('ë§‘ì€ ê³ ë”•', 10, 'bold'))
        self.status_label.pack(side='right', padx=10)
        
        # ë©”ì¸ í‘œì‹œ ì˜ì—­
        main_frame = tk.Frame(self.root, bg='#1a1a2e', padx=20, pady=10)
        main_frame.pack(fill='both', expand=True)
        
        # ì ìˆ˜ í‘œì‹œ
        score_frame = tk.Frame(main_frame, bg='#0f3460', relief='raised', bd=3)
        score_frame.pack(fill='x', pady=(0, 15))
        
        tk.Label(score_frame, text="ğŸ† í˜„ì¬ ì ìˆ˜", bg='#0f3460', fg='#ffa502',
                font=('ë§‘ì€ ê³ ë”•', 16, 'bold')).pack(pady=(15, 5))
        
        self.score_display = tk.Label(score_frame, text="0", bg='#0f3460', fg='white',
                                      font=('ë§‘ì€ ê³ ë”•', 60, 'bold'))
        self.score_display.pack(pady=(0, 15))
        
        # ê±°ë¦¬ ë° ìƒíƒœ í‘œì‹œ
        info_frame = tk.Frame(main_frame, bg='#1a1a2e')
        info_frame.pack(fill='x', pady=(0, 15))
        
        # ê±°ë¦¬ í‘œì‹œ
        distance_frame = tk.Frame(info_frame, bg='#16213e', relief='raised', bd=2)
        distance_frame.pack(side='left', fill='both', expand=True, padx=(0, 10))
        
        tk.Label(distance_frame, text="ğŸ“ ê±°ë¦¬", bg='#16213e', fg='#48dbfb',
                font=('ë§‘ì€ ê³ ë”•', 14, 'bold')).pack(pady=(10, 5))
        
        self.distance_display = tk.Label(distance_frame, text="-- cm", bg='#16213e', fg='white',
                                         font=('ë§‘ì€ ê³ ë”•', 36, 'bold'))
        self.distance_display.pack(pady=(0, 10))
        
        # ìƒíƒœ í‘œì‹œ
        status_frame = tk.Frame(info_frame, bg='#16213e', relief='raised', bd=2)
        status_frame.pack(side='left', fill='both', expand=True)
        
        tk.Label(status_frame, text="ğŸ“Š ìƒíƒœ", bg='#16213e', fg='#48dbfb',
                font=('ë§‘ì€ ê³ ë”•', 14, 'bold')).pack(pady=(10, 5))
        
        self.status_display = tk.Label(status_frame, text="ëŒ€ê¸° ì¤‘", bg='#16213e', fg='#95afc0',
                                       font=('ë§‘ì€ ê³ ë”•', 24, 'bold'))
        self.status_display.pack(pady=(0, 10))
        
        # ë¡œê·¸ ì˜ì—­
        log_frame = tk.Frame(main_frame, bg='#16213e', relief='raised', bd=2)
        log_frame.pack(fill='both', expand=True)
        
        tk.Label(log_frame, text="ğŸ“‹ ì‹¤ì‹œê°„ ë¡œê·¸", bg='#16213e', fg='white',
                font=('ë§‘ì€ ê³ ë”•', 12, 'bold')).pack(anchor='w', padx=10, pady=(10, 5))
        
        self.log_text = scrolledtext.ScrolledText(log_frame, height=10, 
                                                  bg='#0f0f0f', fg='#00ff00',
                                                  font=('Consolas', 10),
                                                  insertbackground='white')
        self.log_text.pack(fill='both', expand=True, padx=10, pady=(0, 10))
        
        # í•˜ë‹¨ ë²„íŠ¼
        bottom_frame = tk.Frame(self.root, bg='#16213e', padx=15, pady=15)
        bottom_frame.pack(fill='x')
        
        self.clear_btn = tk.Button(bottom_frame, text="ğŸ—‘ï¸ ë¡œê·¸ ì§€ìš°ê¸°", command=self.clear_log,
                                   bg='#e84118', fg='white', font=('ë§‘ì€ ê³ ë”•', 10),
                                   padx=20, pady=8, relief='flat', cursor='hand2')
        self.clear_btn.pack(side='left', padx=5)
        
        self.reset_btn = tk.Button(bottom_frame, text="ğŸ”„ ì ìˆ˜ ì´ˆê¸°í™”", command=self.reset_score,
                                   bg='#e67e22', fg='white', font=('ë§‘ì€ ê³ ë”•', 10),
                                   padx=20, pady=8, relief='flat', cursor='hand2')
        self.reset_btn.pack(side='left', padx=5)
        
    def refresh_ports(self):
        ports = serial.tools.list_ports.comports()
        port_list = [port.device for port in ports]
        self.port_combo['values'] = port_list
        if port_list:
            self.port_combo.current(0)
            # ë¡œê·¸ í…ìŠ¤íŠ¸ê°€ ìƒì„±ëœ í›„ì—ë§Œ ë¡œê·¸ ì¶”ê°€
            if hasattr(self, 'log_text'):
                self.add_log(f"âœ“ ì‚¬ìš© ê°€ëŠ¥í•œ í¬íŠ¸: {', '.join(port_list)}")
        else:
            if hasattr(self, 'log_text'):
                self.add_log("âš ï¸ ì‚¬ìš© ê°€ëŠ¥í•œ í¬íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤")
    
    def toggle_connection(self):
        if not self.is_running:
            self.start_connection()
        else:
            self.stop_connection()
    
    def start_connection(self):
        port = self.port_combo.get()
        if not port:
            self.add_log("âŒ í¬íŠ¸ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”")
            return
        
        try:
            self.serial_port = serial.Serial(port, 9600, timeout=1)
            time.sleep(2)  # ì•„ë‘ì´ë…¸ ë¦¬ì…‹ ëŒ€ê¸°
            self.is_running = True
            
            self.connect_btn.config(text="ğŸ”Œ ì—°ê²° í•´ì œ", bg='#e84118')
            self.status_label.config(text="â— ì—°ê²°ë¨", fg='#2ed573')
            self.add_log(f"âœ“ {port} í¬íŠ¸ì— ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤")
            
            # ì½ê¸° ìŠ¤ë ˆë“œ ì‹œì‘
            self.read_thread = threading.Thread(target=self.read_serial, daemon=True)
            self.read_thread.start()
            
        except Exception as e:
            self.add_log(f"âŒ ì—°ê²° ì‹¤íŒ¨: {str(e)}")
    
    def stop_connection(self):
        self.is_running = False
        if self.serial_port:
            self.serial_port.close()
        
        self.connect_btn.config(text="ğŸ”Œ ì—°ê²°", bg='#0f3460')
        self.status_label.config(text="â— ì—°ê²° ì•ˆë¨", fg='#ff4757')
        self.add_log("âœ“ ì—°ê²°ì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤")
    
    def read_serial(self):
        while self.is_running:
            try:
                if self.serial_port and self.serial_port.in_waiting:
                    line = self.serial_port.readline().decode('utf-8', errors='ignore').strip()
                    if line:
                        self.process_line(line)
            except Exception as e:
                self.add_log(f"âŒ ì½ê¸° ì˜¤ë¥˜: {str(e)}")
                self.stop_connection()
                break
            time.sleep(0.05)
    
    def process_line(self, line):
        self.add_log(line)
        
        # ì ìˆ˜ ì¶”ì¶œ
        if "ì ìˆ˜:" in line or "ğŸ’ ì ìˆ˜:" in line:
            match = re.search(r'(\d+)\s*ì ', line)
            if match:
                self.score = int(match.group(1))
                self.update_score()
        
        # ê±°ë¦¬ ì¶”ì¶œ
        if "ê±°ë¦¬:" in line:
            match = re.search(r'ê±°ë¦¬:\s*([\d.]+)\s*cm', line)
            if match:
                self.distance = float(match.group(1))
                self.update_distance()
        
        # ìƒíƒœ ì—…ë°ì´íŠ¸
        if "ğŸ‰" in line or "ë¬¼ì²´ ê°ì§€" in line:
            self.update_status("âœ… ê°ì§€!", "#2ed573")
        elif "ê°ì§€ ì¤‘" in line or "ğŸ”´" in line:
            self.update_status("ğŸ”´ ê°ì§€ ì¤‘", "#ff4757")
        elif "ëŒ€ê¸° ì¤‘" in line or "âšª" in line:
            self.update_status("âšª ëŒ€ê¸° ì¤‘", "#95afc0")
    
    def update_score(self):
        self.score_display.config(text=str(self.score))
    
    def update_distance(self):
        self.distance_display.config(text=f"{self.distance:.1f} cm")
    
    def update_status(self, status, color):
        self.status_display.config(text=status, fg=color)
    
    def add_log(self, message):
        self.log_text.insert(tk.END, f"[{time.strftime('%H:%M:%S')}] {message}\n")
        self.log_text.see(tk.END)
    
    def clear_log(self):
        self.log_text.delete(1.0, tk.END)
        self.add_log("ë¡œê·¸ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤")
    
    def reset_score(self):
        self.score = 0
        self.update_score()
        self.add_log("ì ìˆ˜ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤")

if __name__ == "__main__":
    root = tk.Tk()
    app = ArduinoMonitor(root)
    root.mainloop()

import tkinter as tk
from tkinter import ttk, messagebox
import serial
import serial.tools.list_ports
import threading
import time
import platform

# 운영체제별 소리 재생
system = platform.system()
if system == 'Windows':
    import winsound
elif system == 'Darwin':  # macOS
    import os
elif system == 'Linux':
    import os

class AirHockeyMonitor:
    def __init__(self, root):
        self.root = root
        self.root.title("🏒 Air Hockey Score Monitor - Player 1")
        self.root.geometry("800x800")
        self.root.configure(bg='#0a0a0a')
        
        self.serial_port = None
        self.is_connected = False
        
        # 점수 데이터
        self.player_data = {
            'score': 0,
            'distance': 0,
            'status': 'ready'
        }
        
        self.game_status = 'ready'  # ready, playing, finished
        self.max_score = 7  # 목표 점수
        
        self.setup_ui()
        
    def setup_ui(self):
        # 상단 연결 프레임
        top_frame = tk.Frame(self.root, bg='#1a1a1a', padx=20, pady=15)
        top_frame.pack(fill='x')
        
        # Player 1 연결
        tk.Label(top_frame, text="포트:", bg='#1a1a1a', fg='white', 
                font=('Arial', 11, 'bold')).pack(side='left', padx=5)
        
        self.port_combo = ttk.Combobox(top_frame, width=15, state='readonly', 
                                        font=('Arial', 10))
        self.port_combo.pack(side='left', padx=5)
        
        self.connect_btn = tk.Button(top_frame, text="🔌 연결", 
                                      command=self.toggle_connection,
                                      bg='#00ff00', fg='black', font=('Arial', 11, 'bold'),
                                      padx=20, pady=8, cursor='hand2')
        self.connect_btn.pack(side='left', padx=10)
        
        self.status_label = tk.Label(top_frame, text="● 연결 안됨", bg='#1a1a1a', 
                                      fg='#ff0000', font=('Arial', 11, 'bold'))
        self.status_label.pack(side='left', padx=10)
        
        # 새로고침 및 리셋 버튼
        self.refresh_btn = tk.Button(top_frame, text="🔄 새로고침", command=self.refresh_ports,
                                     bg='#333333', fg='white', font=('Arial', 11),
                                     padx=15, pady=8, cursor='hand2')
        self.refresh_btn.pack(side='right', padx=5)
        
        self.reset_btn = tk.Button(top_frame, text="🔄 점수 리셋", command=self.reset_game,
                                   bg='#cc0000', fg='white', font=('Arial', 11, 'bold'),
                                   padx=20, pady=8, cursor='hand2')
        self.reset_btn.pack(side='right', padx=5)
        
        # 게임 상태 표시
        status_frame = tk.Frame(self.root, bg='#1a1a1a', padx=20, pady=15)
        status_frame.pack(fill='x')
        
        self.game_status_label = tk.Label(status_frame, text="🏒 READY TO PLAY", bg='#1a1a1a', 
                                          fg='#00ff00', font=('Arial', 28, 'bold'))
        self.game_status_label.pack()
        
        tk.Label(status_frame, text=f"First to {self.max_score} goals wins!", 
                bg='#1a1a1a', fg='#888888', font=('Arial', 14)).pack(pady=5)
        
        # 메인 스코어보드
        main_frame = tk.Frame(self.root, bg='#0a0a0a', padx=10, pady=10)
        main_frame.pack(fill='both', expand=True)
        
        # Player 1 영역
        self.player_frame = self.create_player_display(main_frame, '#ff0000')
        self.player_frame.pack(fill='both', expand=True, padx=20, pady=10)
        
        self.refresh_ports()
        
    def create_player_display(self, parent, color):
        frame = tk.Frame(parent, bg='#1a1a1a', relief='solid', bd=3)
        
        # 헤더
        header = tk.Frame(frame, bg=color, pady=20)
        header.pack(fill='x')
        
        tk.Label(header, text="PLAYER 1", bg=color, fg='white',
                font=('Arial', 32, 'bold')).pack()
        
        # 메인 점수
        score_frame = tk.Frame(frame, bg='#1a1a1a', pady=30)
        score_frame.pack(fill='both', expand=True)
        
        tk.Label(score_frame, text="SCORE", bg='#1a1a1a', fg='#888888',
                font=('Arial', 16)).pack()
        
        score_label = tk.Label(score_frame, text="0", bg='#1a1a1a', fg=color,
                              font=('Arial', 120, 'bold'))
        score_label.pack(pady=20)
        
        # 센서 거리
        sensor_frame = tk.Frame(frame, bg='#2a2a2a', padx=20, pady=20)
        sensor_frame.pack(fill='x', padx=20, pady=10)
        
        tk.Label(sensor_frame, text="📡 SENSOR DISTANCE", bg='#2a2a2a', fg='#888888',
                font=('Arial', 12, 'bold')).pack()
        
        distance_label = tk.Label(sensor_frame, text="-- cm", bg='#2a2a2a', 
                                 fg='white', font=('Courier', 28, 'bold'))
        distance_label.pack(pady=10)
        
        distance_bar = tk.Canvas(sensor_frame, height=30, bg='#1a1a1a', 
                                highlightthickness=0)
        distance_bar.pack(fill='x', pady=10)
        
        # 상태
        status_frame = tk.Frame(frame, bg='#1a1a1a', pady=15)
        status_frame.pack(fill='x')
        
        status_label = tk.Label(status_frame, text="● READY", bg='#1a1a1a', 
                               fg='#ffff00', font=('Arial', 14, 'bold'))
        status_label.pack()
        
        # 위젯 참조 저장
        frame.score_label = score_label
        frame.distance_label = distance_label
        frame.distance_bar = distance_bar
        frame.status_label = status_label
        
        return frame
        
    def refresh_ports(self):
        ports = serial.tools.list_ports.comports()
        port_list = [port.device for port in ports]
        self.port_combo['values'] = port_list
        if port_list:
            if not self.port_combo.get():
                self.port_combo.current(0)
    
    def toggle_connection(self):
        if not self.is_connected:
            self.connect_arduino()
        else:
            self.disconnect_arduino()
    
    def connect_arduino(self):
        port = self.port_combo.get()
        if not port:
            messagebox.showerror("에러", "포트를 선택해주세요")
            return
        
        try:
            self.serial_port = serial.Serial(port, 9600, timeout=1)
            time.sleep(2)  # Arduino 리셋 대기
            self.is_connected = True
            
            self.connect_btn.config(text="🔌 연결 해제", bg='#ff0000')
            self.status_label.config(text="● 연결됨", fg='#00ff00')
            
            # 읽기 스레드 시작
            thread = threading.Thread(target=self.read_serial, daemon=True)
            thread.start()
            
        except Exception as e:
            messagebox.showerror("연결 실패", f"Arduino 연결 실패:\n{str(e)}")
    
    def disconnect_arduino(self):
        self.is_connected = False
        if self.serial_port:
            self.serial_port.close()
        
        self.connect_btn.config(text="🔌 연결", bg='#00ff00')
        self.status_label.config(text="● 연결 안됨", fg='#ff0000')
    
    def read_serial(self):
        while self.is_connected:
            try:
                if self.serial_port and self.serial_port.in_waiting:
                    line = self.serial_port.readline().decode('utf-8', errors='ignore').strip()
                    if line:
                        self.process_data(line)
            except Exception as e:
                print(f"읽기 오류: {e}")
                break
            time.sleep(0.01)
    
    def process_data(self, data):
        # 데이터 형식: "PLAYER1:DIST:15.5" 또는 "PLAYER1:GOAL:3"
        try:
            parts = data.split(':')
            if len(parts) < 3:
                return
            
            player_id = parts[0]
            data_type = parts[1]
            value = parts[2]
            
            if data_type == 'DIST':
                distance = float(value)
                self.player_data['distance'] = distance
                self.update_distance_display(distance)
                
            elif data_type == 'GOAL':
                # 게임이 끝났으면 득점 무시
                if self.game_status == 'finished':
                    print("게임 종료됨 - 득점 무시")
                    return
                
                score = int(value)
                self.player_data['score'] = score
                self.update_score_display(score)
                self.check_winner()
                
        except Exception as e:
            print(f"데이터 처리 오류: {e}")
    
    def play_goal_sound(self):
        """득점 시 소리 재생"""
        def play_sound():
            try:
                if system == 'Windows':
                    # Windows: 시스템 비프음 + 멜로디
                    frequencies = [800, 1000, 1200]  # 도-미-솔
                    for freq in frequencies:
                        winsound.Beep(freq, 200)
                        time.sleep(0.05)
                elif system == 'Darwin':  # macOS
                    os.system('afplay /System/Library/Sounds/Glass.aiff')
                elif system == 'Linux':
                    os.system('paplay /usr/share/sounds/freedesktop/stereo/complete.oga 2>/dev/null || beep -f 1000 -l 300')
            except Exception as e:
                print(f"소리 재생 오류: {e}")
        
        # 소리를 별도 스레드에서 재생 (UI 멈춤 방지)
        sound_thread = threading.Thread(target=play_sound, daemon=True)
        sound_thread.start()
    
    def update_score_display(self, score):
        color = '#ff0000'
        self.player_frame.score_label.config(text=str(score), fg=color)
        
        # 🎵 득점 소리 재생!
        self.play_goal_sound()
        
        # 득점 효과
        self.player_frame.score_label.config(font=('Arial', 140, 'bold'))
        self.root.after(200, lambda: self.player_frame.score_label.config(font=('Arial', 120, 'bold')))
        
        if self.game_status == 'ready':
            self.game_status = 'playing'
            self.game_status_label.config(text="🏒 GAME ON!", fg='#00ff00')
    
    def update_distance_display(self, distance):
        # 거리에 따른 색상 변경
        if distance < 15:
            color = '#ff0000'
            status = "⚠️ DANGER ZONE!"
        elif distance < 30:
            color = '#ffaa00'
            status = "● PLAYING"
        else:
            color = '#00ff00'
            status = "● READY"
        
        self.player_frame.distance_label.config(text=f"{distance:.1f} cm", fg=color)
        self.player_frame.status_label.config(text=status, fg=color)
        
        # 거리 바 그래프
        canvas = self.player_frame.distance_bar
        canvas.delete('all')
        max_dist = 100
        bar_width = min(distance / max_dist, 1.0) * canvas.winfo_width()
        canvas.create_rectangle(0, 0, bar_width, 30, fill=color, outline='')
    
    def check_winner(self):
        if self.player_data['score'] >= self.max_score:
            self.game_status = 'finished'
            self.game_status_label.config(text="🏆 YOU WIN!", fg='#ff0000')
            self.player_frame.status_label.config(text="🏆 WINNER!", fg='#ffff00')
            
            # 승리 소리 (더 화려하게)
            self.play_victory_sound()
            
            messagebox.showinfo("게임 종료", f"축하합니다! {self.max_score}점 달성!")
    
    def play_victory_sound(self):
        """승리 시 특별한 소리"""
        def play_sound():
            try:
                if system == 'Windows':
                    # 승리 멜로디
                    melody = [
                        (523, 200), (659, 200), (784, 200),  # 도-미-솔
                        (1047, 400), (784, 200), (1047, 600)  # 도(높음)-솔-도(높음)
                    ]
                    for freq, duration in melody:
                        winsound.Beep(freq, duration)
                        time.sleep(0.05)
                elif system == 'Darwin':  # macOS
                    os.system('afplay /System/Library/Sounds/Hero.aiff')
                elif system == 'Linux':
                    os.system('paplay /usr/share/sounds/freedesktop/stereo/complete.oga 2>/dev/null')
            except Exception as e:
                print(f"승리 소리 재생 오류: {e}")
        
        sound_thread = threading.Thread(target=play_sound, daemon=True)
        sound_thread.start()
    
    def reset_game(self):
        # 아두이노에 리셋 명령 전송
        if self.is_connected and self.serial_port:
            try:
                self.serial_port.write(b'RESET\n')
                print("아두이노에 리셋 명령 전송")
            except Exception as e:
                print(f"리셋 명령 전송 오류: {e}")
        
        self.game_status = 'ready'
        self.game_status_label.config(text="🏒 READY TO PLAY", fg='#00ff00')
        
        # 데이터 초기화
        self.player_data = {'score': 0, 'distance': 0, 'status': 'ready'}
        
        # UI 업데이트
        self.player_frame.score_label.config(text="0", fg='#ff0000')
        self.player_frame.distance_label.config(text="-- cm", fg='white')
        self.player_frame.status_label.config(text="● READY", fg='#ffff00')
        self.player_frame.distance_bar.delete('all')

if __name__ == "__main__":
    root = tk.Tk()
    app = AirHockeyMonitor(root)
    root.mainloop()

import tkinter as tk
from tkinter import ttk, messagebox
import serial
import serial.tools.list_ports
import threading
import time
import platform

# ìš´ì˜ì²´ì œë³„ ì†Œë¦¬ ì¬ìƒ
system = platform.system()
if system == 'Windows':
    import winsound
elif system == 'Darwin':  # macOS
    import os
elif system == 'Linux':
    import os

class AirHockeyMonitor:
    def __init__(self, root):
        self.root = root
        self.root.title("ğŸ’ Air Hockey Score Monitor - Player 1")
        self.root.geometry("800x800")
        self.root.configure(bg='#0a0a0a')
        
        self.serial_port = None
        self.is_connected = False
        
        # ì ìˆ˜ ë°ì´í„°
        self.player_data = {
            'score': 0,
            'distance': 0,
            'status': 'ready'
        }
        
        self.game_status = 'ready'  # ready, playing, finished
        self.max_score = 7  # ëª©í‘œ ì ìˆ˜
        
        self.setup_ui()
        
    def setup_ui(self):
        # ìƒë‹¨ ì—°ê²° í”„ë ˆì„
        top_frame = tk.Frame(self.root, bg='#1a1a1a', padx=20, pady=15)
        top_frame.pack(fill='x')
        
        # Player 1 ì—°ê²°
        tk.Label(top_frame, text="í¬íŠ¸:", bg='#1a1a1a', fg='white', 
                font=('Arial', 11, 'bold')).pack(side='left', padx=5)
        
        self.port_combo = ttk.Combobox(top_frame, width=15, state='readonly', 
                                        font=('Arial', 10))
        self.port_combo.pack(side='left', padx=5)
        
        self.connect_btn = tk.Button(top_frame, text="ğŸ”Œ ì—°ê²°", 
                                      command=self.toggle_connection,
                                      bg='#00ff00', fg='black', font=('Arial', 11, 'bold'),
                                      padx=20, pady=8, cursor='hand2')
        self.connect_btn.pack(side='left', padx=10)
        
        self.status_label = tk.Label(top_frame, text="â— ì—°ê²° ì•ˆë¨", bg='#1a1a1a', 
                                      fg='#ff0000', font=('Arial', 11, 'bold'))
        self.status_label.pack(side='left', padx=10)
        
        # ìƒˆë¡œê³ ì¹¨ ë° ë¦¬ì…‹ ë²„íŠ¼
        self.refresh_btn = tk.Button(top_frame, text="ğŸ”„ ìƒˆë¡œê³ ì¹¨", command=self.refresh_ports,
                                     bg='#333333', fg='white', font=('Arial', 11),
                                     padx=15, pady=8, cursor='hand2')
        self.refresh_btn.pack(side='right', padx=5)
        
        self.reset_btn = tk.Button(top_frame, text="ğŸ”„ ì ìˆ˜ ë¦¬ì…‹", command=self.reset_game,
                                   bg='#cc0000', fg='white', font=('Arial', 11, 'bold'),
                                   padx=20, pady=8, cursor='hand2')
        self.reset_btn.pack(side='right', padx=5)
        
        # ê²Œì„ ìƒíƒœ í‘œì‹œ
        status_frame = tk.Frame(self.root, bg='#1a1a1a', padx=20, pady=15)
        status_frame.pack(fill='x')
        
        self.game_status_label = tk.Label(status_frame, text="ğŸ’ READY TO PLAY", bg='#1a1a1a', 
                                          fg='#00ff00', font=('Arial', 28, 'bold'))
        self.game_status_label.pack()
        
        tk.Label(status_frame, text=f"First to {self.max_score} goals wins!", 
                bg='#1a1a1a', fg='#888888', font=('Arial', 14)).pack(pady=5)
        
        # ë©”ì¸ ìŠ¤ì½”ì–´ë³´ë“œ
        main_frame = tk.Frame(self.root, bg='#0a0a0a', padx=10, pady=10)
        main_frame.pack(fill='both', expand=True)
        
        # Player 1 ì˜ì—­
        self.player_frame = self.create_player_display(main_frame, '#ff0000')
        self.player_frame.pack(fill='both', expand=True, padx=20, pady=10)
        
        self.refresh_ports()
        
    def create_player_display(self, parent, color):
        frame = tk.Frame(parent, bg='#1a1a1a', relief='solid', bd=3)
        
        # í—¤ë”
        header = tk.Frame(frame, bg=color, pady=20)
        header.pack(fill='x')
        
        tk.Label(header, text="PLAYER 1", bg=color, fg='white',
                font=('Arial', 32, 'bold')).pack()
        
        # ë©”ì¸ ì ìˆ˜
        score_frame = tk.Frame(frame, bg='#1a1a1a', pady=30)
        score_frame.pack(fill='both', expand=True)
        
        tk.Label(score_frame, text="SCORE", bg='#1a1a1a', fg='#888888',
                font=('Arial', 16)).pack()
        
        score_label = tk.Label(score_frame, text="0", bg='#1a1a1a', fg=color,
                              font=('Arial', 120, 'bold'))
        score_label.pack(pady=20)
        
        # ì„¼ì„œ ê±°ë¦¬
        sensor_frame = tk.Frame(frame, bg='#2a2a2a', padx=20, pady=20)
        sensor_frame.pack(fill='x', padx=20, pady=10)
        
        tk.Label(sensor_frame, text="ğŸ“¡ SENSOR DISTANCE", bg='#2a2a2a', fg='#888888',
                font=('Arial', 12, 'bold')).pack()
        
        distance_label = tk.Label(sensor_frame, text="-- cm", bg='#2a2a2a', 
                                 fg='white', font=('Courier', 28, 'bold'))
        distance_label.pack(pady=10)
        
        distance_bar = tk.Canvas(sensor_frame, height=30, bg='#1a1a1a', 
                                highlightthickness=0)
        distance_bar.pack(fill='x', pady=10)
        
        # ìƒíƒœ
        status_frame = tk.Frame(frame, bg='#1a1a1a', pady=15)
        status_frame.pack(fill='x')
        
        status_label = tk.Label(status_frame, text="â— READY", bg='#1a1a1a', 
                               fg='#ffff00', font=('Arial', 14, 'bold'))
        status_label.pack()
        
        # ìœ„ì ¯ ì°¸ì¡° ì €ì¥
        frame.score_label = score_label
        frame.distance_label = distance_label
        frame.distance_bar = distance_bar
        frame.status_label = status_label
        
        return frame
        
    def refresh_ports(self):
        ports = serial.tools.list_ports.comports()
        port_list = [port.device for port in ports]
        self.port_combo['values'] = port_list
        if port_list:
            if not self.port_combo.get():
                self.port_combo.current(0)
    
    def toggle_connection(self):
        if not self.is_connected:
            self.connect_arduino()
        else:
            self.disconnect_arduino()
    
    def connect_arduino(self):
        port = self.port_combo.get()
        if not port:
            messagebox.showerror("ì—ëŸ¬", "í¬íŠ¸ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”")
            return
        
        try:
            self.serial_port = serial.Serial(port, 9600, timeout=1)
            time.sleep(2)  # Arduino ë¦¬ì…‹ ëŒ€ê¸°
            self.is_connected = True
            
            self.connect_btn.config(text="ğŸ”Œ ì—°ê²° í•´ì œ", bg='#ff0000')
            self.status_label.config(text="â— ì—°ê²°ë¨", fg='#00ff00')
            
            # ì½ê¸° ìŠ¤ë ˆë“œ ì‹œì‘
            thread = threading.Thread(target=self.read_serial, daemon=True)
            thread.start()
            
        except Exception as e:
            messagebox.showerror("ì—°ê²° ì‹¤íŒ¨", f"Arduino ì—°ê²° ì‹¤íŒ¨:\n{str(e)}")
    
    def disconnect_arduino(self):
        self.is_connected = False
        if self.serial_port:
            self.serial_port.close()
        
        self.connect_btn.config(text="ğŸ”Œ ì—°ê²°", bg='#00ff00')
        self.status_label.config(text="â— ì—°ê²° ì•ˆë¨", fg='#ff0000')
    
    def read_serial(self):
        while self.is_connected:
            try:
                if self.serial_port and self.serial_port.in_waiting:
                    line = self.serial_port.readline().decode('utf-8', errors='ignore').strip()
                    if line:
                        self.process_data(line)
            except Exception as e:
                print(f"ì½ê¸° ì˜¤ë¥˜: {e}")
                break
            time.sleep(0.01)
    
    def process_data(self, data):
        # ë°ì´í„° í˜•ì‹: "PLAYER1:DIST:15.5" ë˜ëŠ” "PLAYER1:GOAL:3"
        try:
            parts = data.split(':')
            if len(parts) < 3:
                return
            
            player_id = parts[0]
            data_type = parts[1]
            value = parts[2]
            
            if data_type == 'DIST':
                distance = float(value)
                self.player_data['distance'] = distance
                self.update_distance_display(distance)
                
            elif data_type == 'GOAL':
                # ê²Œì„ì´ ëë‚¬ìœ¼ë©´ ë“ì  ë¬´ì‹œ
                if self.game_status == 'finished':
                    print("ê²Œì„ ì¢…ë£Œë¨ - ë“ì  ë¬´ì‹œ")
                    return
                
                score = int(value)
                self.player_data['score'] = score
                self.update_score_display(score)
                self.check_winner()
                
        except Exception as e:
            print(f"ë°ì´í„° ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
    
    def play_goal_sound(self):
        """ë“ì  ì‹œ ì†Œë¦¬ ì¬ìƒ"""
        def play_sound():
            try:
                if system == 'Windows':
                    # Windows: ì‹œìŠ¤í…œ ë¹„í”„ìŒ + ë©œë¡œë””
                    frequencies = [800, 1000, 1200]  # ë„-ë¯¸-ì†”
                    for freq in frequencies:
                        winsound.Beep(freq, 200)
                        time.sleep(0.05)
                elif system == 'Darwin':  # macOS
                    os.system('afplay /System/Library/Sounds/Glass.aiff')
                elif system == 'Linux':
                    os.system('paplay /usr/share/sounds/freedesktop/stereo/complete.oga 2>/dev/null || beep -f 1000 -l 300')
            except Exception as e:
                print(f"ì†Œë¦¬ ì¬ìƒ ì˜¤ë¥˜: {e}")
        
        # ì†Œë¦¬ë¥¼ ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ ì¬ìƒ (UI ë©ˆì¶¤ ë°©ì§€)
        sound_thread = threading.Thread(target=play_sound, daemon=True)
        sound_thread.start()
    
    def update_score_display(self, score):
        color = '#ff0000'
        self.player_frame.score_label.config(text=str(score), fg=color)
        
        # ğŸµ ë“ì  ì†Œë¦¬ ì¬ìƒ!
        self.play_goal_sound()
        
        # ë“ì  íš¨ê³¼
        self.player_frame.score_label.config(font=('Arial', 140, 'bold'))
        self.root.after(200, lambda: self.player_frame.score_label.config(font=('Arial', 120, 'bold')))
        
        if self.game_status == 'ready':
            self.game_status = 'playing'
            self.game_status_label.config(text="ğŸ’ GAME ON!", fg='#00ff00')
    
    def update_distance_display(self, distance):
        # ê±°ë¦¬ì— ë”°ë¥¸ ìƒ‰ìƒ ë³€ê²½
        if distance < 15:
            color = '#ff0000'
            status = "âš ï¸ DANGER ZONE!"
        elif distance < 30:
            color = '#ffaa00'
            status = "â— PLAYING"
        else:
            color = '#00ff00'
            status = "â— READY"
        
        self.player_frame.distance_label.config(text=f"{distance:.1f} cm", fg=color)
        self.player_frame.status_label.config(text=status, fg=color)
        
        # ê±°ë¦¬ ë°” ê·¸ë˜í”„
        canvas = self.player_frame.distance_bar
        canvas.delete('all')
        max_dist = 100
        bar_width = min(distance / max_dist, 1.0) * canvas.winfo_width()
        canvas.create_rectangle(0, 0, bar_width, 30, fill=color, outline='')
    
    def check_winner(self):
        if self.player_data['score'] >= self.max_score:
            self.game_status = 'finished'
            self.game_status_label.config(text="ğŸ† YOU WIN!", fg='#ff0000')
            self.player_frame.status_label.config(text="ğŸ† WINNER!", fg='#ffff00')
            
            # ìŠ¹ë¦¬ ì†Œë¦¬ (ë” í™”ë ¤í•˜ê²Œ)
            self.play_victory_sound()
            
            messagebox.showinfo("ê²Œì„ ì¢…ë£Œ", f"ì¶•í•˜í•©ë‹ˆë‹¤! {self.max_score}ì  ë‹¬ì„±!")
    
    def play_victory_sound(self):
        """ìŠ¹ë¦¬ ì‹œ íŠ¹ë³„í•œ ì†Œë¦¬"""
        def play_sound():
            try:
                if system == 'Windows':
                    # ìŠ¹ë¦¬ ë©œë¡œë””
                    melody = [
                        (523, 200), (659, 200), (784, 200),  # ë„-ë¯¸-ì†”
                        (1047, 400), (784, 200), (1047, 600)  # ë„(ë†’ìŒ)-ì†”-ë„(ë†’ìŒ)
                    ]
                    for freq, duration in melody:
                        winsound.Beep(freq, duration)
                        time.sleep(0.05)
                elif system == 'Darwin':  # macOS
                    os.system('afplay /System/Library/Sounds/Hero.aiff')
                elif system == 'Linux':
                    os.system('paplay /usr/share/sounds/freedesktop/stereo/complete.oga 2>/dev/null')
            except Exception as e:
                print(f"ìŠ¹ë¦¬ ì†Œë¦¬ ì¬ìƒ ì˜¤ë¥˜: {e}")
        
        sound_thread = threading.Thread(target=play_sound, daemon=True)
        sound_thread.start()
    
    def reset_game(self):
        # ì•„ë‘ì´ë…¸ì— ë¦¬ì…‹ ëª…ë ¹ ì „ì†¡
        if self.is_connected and self.serial_port:
            try:
                self.serial_port.write(b'RESET\n')
                print("ì•„ë‘ì´ë…¸ì— ë¦¬ì…‹ ëª…ë ¹ ì „ì†¡")
            except Exception as e:
                print(f"ë¦¬ì…‹ ëª…ë ¹ ì „ì†¡ ì˜¤ë¥˜: {e}")
        
        self.game_status = 'ready'
        self.game_status_label.config(text="ğŸ’ READY TO PLAY", fg='#00ff00')
        
        # ë°ì´í„° ì´ˆê¸°í™”
        self.player_data = {'score': 0, 'distance': 0, 'status': 'ready'}
        
        # UI ì—…ë°ì´íŠ¸
        self.player_frame.score_label.config(text="0", fg='#ff0000')
        self.player_frame.distance_label.config(text="-- cm", fg='white')
        self.player_frame.status_label.config(text="â— READY", fg='#ffff00')
        self.player_frame.distance_bar.delete('all')

if __name__ == "__main__":
    root = tk.Tk()
    app = AirHockeyMonitor(root)
    root.mainloop()

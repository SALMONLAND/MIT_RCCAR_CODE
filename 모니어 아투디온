// 2대 차량용 듀얼 초음파 센서 시스템

// Car 1 센서 (Section 1)
#define TRIG_PIN_1 2
#define ECHO_PIN_1 3

// Car 2 센서 (Section 2)
#define TRIG_PIN_2 4
#define ECHO_PIN_2 5

#define THRESHOLD 15  // 감지 거리 임계값 (cm)
#define TOTAL_LAPS 3  // 총 랩 수

// Car 1 상태
int car1_lap_count = 0;
unsigned long car1_lap_start = 0;
bool car1_detecting = false;
bool car1_finished = false;

// Car 2 상태
int car2_lap_count = 0;
unsigned long car2_lap_start = 0;
bool car2_detecting = false;
bool car2_finished = false;

bool race_started = false;
unsigned long race_start_time = 0;
unsigned long last_update = 0;

void setup() {
  Serial.begin(9600);
  
  // Car 1 센서 핀 설정
  pinMode(TRIG_PIN_1, OUTPUT);
  pinMode(ECHO_PIN_1, INPUT);
  
  // Car 2 센서 핀 설정
  pinMode(TRIG_PIN_2, OUTPUT);
  pinMode(ECHO_PIN_2, INPUT);
  
  Serial.println("=================================");
  Serial.println("F1 Dual Race System Ready");
  Serial.println("=================================");
}

void loop() {
  // Python으로부터 명령 수신
  if (Serial.available() > 0) {
    String command = Serial.readStringUntil('\n');
    command.trim();
    
    if (command == "START") {
      startRace();
    } else if (command == "RESET") {
      resetRace();
    }
  }
  
  if (!race_started) {
    delay(100);
    return;
  }
  
  // Car 1 센서 측정
  float distance1 = measureDistance(TRIG_PIN_1, ECHO_PIN_1);
  
  // Car 2 센서 측정
  float distance2 = measureDistance(TRIG_PIN_2, ECHO_PIN_2);
  
  // 거리 데이터 전송 (0.1초마다)
  unsigned long current_time = millis();
  if (current_time - last_update >= 100) {
    last_update = current_time;
    
    Serial.print("CAR1:DIST:");
    Serial.println(distance1, 1);
    
    Serial.print("CAR2:DIST:");
    Serial.println(distance2, 1);
    
    // 현재 랩 타임 전송
    if (!car1_finished && car1_lap_count < TOTAL_LAPS) {
      unsigned long car1_current_time = current_time - car1_lap_start;
      Serial.print("CAR1:TIME:");
      Serial.println(car1_current_time);
    }
    
    if (!car2_finished && car2_lap_count < TOTAL_LAPS) {
      unsigned long car2_current_time = current_time - car2_lap_start;
      Serial.print("CAR2:TIME:");
      Serial.println(car2_current_time);
    }
  }
  
  // Car 1 감지 처리
  if (distance1 > 0 && distance1 < THRESHOLD && !car1_detecting && !car1_finished) {
    car1_detecting = true;
    handleLapComplete(1);
  } else if (distance1 >= THRESHOLD || distance1 == 0) {
    car1_detecting = false;
  }
  
  // Car 2 감지 처리
  if (distance2 > 0 && distance2 < THRESHOLD && !car2_detecting && !car2_finished) {
    car2_detecting = true;
    handleLapComplete(2);
  } else if (distance2 >= THRESHOLD || distance2 == 0) {
    car2_detecting = false;
  }
  
  delay(50);  // 센서 안정화
}

float measureDistance(int trigPin, int echoPin) {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  
  long duration = pulseIn(echoPin, HIGH, 30000);
  float distance = duration * 0.034 / 2;
  
  // 유효하지 않은 값 필터링
  if (distance > 400 || distance == 0) {
    return 999;  // 범위 밖
  }
  
  return distance;
}

void handleLapComplete(int car_num) {
  unsigned long current_time = millis();
  unsigned long lap_time;
  
  if (car_num == 1) {
    car1_lap_count++;
    lap_time = current_time - car1_lap_start;
    
    Serial.print("CAR1:LAP:");
    Serial.println(lap_time);
    
    Serial.print("[CAR 1] Lap ");
    Serial.print(car1_lap_count);
    Serial.print(" completed: ");
    Serial.print(lap_time);
    Serial.println(" ms");
    
    if (car1_lap_count >= TOTAL_LAPS) {
      car1_finished = true;
      Serial.println("[CAR 1] *** FINISHED! ***");
    } else {
      car1_lap_start = current_time;  // 다음 랩 시작
    }
    
  } else if (car_num == 2) {
    car2_lap_count++;
    lap_time = current_time - car2_lap_start;
    
    Serial.print("CAR2:LAP:");
    Serial.println(lap_time);
    
    Serial.print("[CAR 2] Lap ");
    Serial.print(car2_lap_count);
    Serial.print(" completed: ");
    Serial.print(lap_time);
    Serial.println(" ms");
    
    if (car2_lap_count >= TOTAL_LAPS) {
      car2_finished = true;
      Serial.println("[CAR 2] *** FINISHED! ***");
    } else {
      car2_lap_start = current_time;  // 다음 랩 시작
    }
  }
}

void startRace() {
  Serial.println("=================================");
  Serial.println(">>> RACE START! <<<");
  Serial.println("=================================");
  
  race_started = true;
  race_start_time = millis();
  car1_lap_start = race_start_time;
  car2_lap_start = race_start_time;
  last_update = race_start_time;
}

void resetRace() {
  Serial.println("=================================");
  Serial.println(">>> RACE RESET <<<");
  Serial.println("=================================");
  
  race_started = false;
  
  car1_lap_count = 0;
  car1_lap_start = 0;
  car1_detecting = false;
  car1_finished = false;
  
  car2_lap_count = 0;
  car2_lap_start = 0;
  car2_detecting = false;
  car2_finished = false;
  
  race_start_time = 0;
  last_update = 0;
  
  Serial.println("System ready. Waiting for START command...");
}
